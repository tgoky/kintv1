{"version":3,"sources":["../../../../../src/internal/scheduler/performanceTimestampProvider.ts","../../../../../src/internal/scheduler/animationFrameProvider.ts","../../../../../../src/internal/observable/dom/animationFrames.ts","../../../../../src/internal/util/Immediate.ts","../../../../../src/internal/scheduler/immediateProvider.ts","../../../../../src/internal/scheduler/AsapAction.ts","../../../../../src/internal/scheduler/AsapScheduler.ts","../../../../../src/internal/scheduler/asap.ts","../../../../../src/internal/scheduler/QueueAction.ts","../../../../../src/internal/scheduler/QueueScheduler.ts","../../../../../src/internal/scheduler/queue.ts","../../../../../src/internal/scheduler/AnimationFrameAction.ts","../../../../../src/internal/scheduler/AnimationFrameScheduler.ts","../../../../../src/internal/scheduler/animationFrame.ts","../../../../../src/internal/scheduler/VirtualTimeScheduler.ts","../../../../../src/internal/util/isObservable.ts","../../../../src/internal/lastValueFrom.ts","../../../../../src/internal/observable/bindCallbackInternals.ts","../../../../../src/internal/observable/bindCallback.ts","../../../../../src/internal/observable/bindNodeCallback.ts","../../../../../src/internal/observable/connectable.ts","../../../../../src/internal/observable/forkJoin.ts","../../../../../src/internal/observable/generate.ts","../../../../../src/internal/observable/iif.ts","../../../../../src/internal/observable/never.ts","../../../../../src/internal/observable/pairs.ts","../../../../../src/internal/observable/partition.ts","../../../../../src/internal/observable/range.ts","../../../../../src/internal/observable/using.ts","../../../../../src/internal/observable/merge.ts"],"names":["nextHandle","work"],"mappings":"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","file":"static/js/38.1e0b8c72.chunk.js","sourcesContent":["export var performanceTimestampProvider = {\n    now: function () {\n        return (performanceTimestampProvider.delegate || performance).now();\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=performanceTimestampProvider.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { Subscription } from '../Subscription';\nexport var animationFrameProvider = {\n    schedule: function (callback) {\n        var request = requestAnimationFrame;\n        var cancel = cancelAnimationFrame;\n        var delegate = animationFrameProvider.delegate;\n        if (delegate) {\n            request = delegate.requestAnimationFrame;\n            cancel = delegate.cancelAnimationFrame;\n        }\n        var handle = request(function (timestamp) {\n            cancel = undefined;\n            callback(timestamp);\n        });\n        return new Subscription(function () { return cancel === null || cancel === void 0 ? void 0 : cancel(handle); });\n    },\n    requestAnimationFrame: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = animationFrameProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.requestAnimationFrame) || requestAnimationFrame).apply(void 0, __spreadArray([], __read(args)));\n    },\n    cancelAnimationFrame: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = animationFrameProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.cancelAnimationFrame) || cancelAnimationFrame).apply(void 0, __spreadArray([], __read(args)));\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=animationFrameProvider.js.map","import { Observable } from '../../Observable';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\nexport function animationFrames(timestampProvider) {\n    return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\nfunction animationFramesFactory(timestampProvider) {\n    return new Observable(function (subscriber) {\n        var provider = timestampProvider || performanceTimestampProvider;\n        var start = provider.now();\n        var id = 0;\n        var run = function () {\n            if (!subscriber.closed) {\n                id = animationFrameProvider.requestAnimationFrame(function (timestamp) {\n                    id = 0;\n                    var now = provider.now();\n                    subscriber.next({\n                        timestamp: timestampProvider ? now : timestamp,\n                        elapsed: now - start,\n                    });\n                    run();\n                });\n            }\n        };\n        run();\n        return function () {\n            if (id) {\n                animationFrameProvider.cancelAnimationFrame(id);\n            }\n        };\n    });\n}\nvar DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n//# sourceMappingURL=animationFrames.js.map","var nextHandle = 1;\nvar resolved;\nvar activeHandles = {};\nfunction findAndClearHandle(handle) {\n    if (handle in activeHandles) {\n        delete activeHandles[handle];\n        return true;\n    }\n    return false;\n}\nexport var Immediate = {\n    setImmediate: function (cb) {\n        var handle = nextHandle++;\n        activeHandles[handle] = true;\n        if (!resolved) {\n            resolved = Promise.resolve();\n        }\n        resolved.then(function () { return findAndClearHandle(handle) && cb(); });\n        return handle;\n    },\n    clearImmediate: function (handle) {\n        findAndClearHandle(handle);\n    },\n};\nexport var TestTools = {\n    pending: function () {\n        return Object.keys(activeHandles).length;\n    }\n};\n//# sourceMappingURL=Immediate.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { Immediate } from '../util/Immediate';\nvar setImmediate = Immediate.setImmediate, clearImmediate = Immediate.clearImmediate;\nexport var immediateProvider = {\n    setImmediate: function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var delegate = immediateProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.setImmediate) || setImmediate).apply(void 0, __spreadArray([], __read(args)));\n    },\n    clearImmediate: function (handle) {\n        var delegate = immediateProvider.delegate;\n        return ((delegate === null || delegate === void 0 ? void 0 : delegate.clearImmediate) || clearImmediate)(handle);\n    },\n    delegate: undefined,\n};\n//# sourceMappingURL=immediateProvider.js.map","import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { immediateProvider } from './immediateProvider';\nvar AsapAction = (function (_super) {\n    __extends(AsapAction, _super);\n    function AsapAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n    };\n    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        var _a;\n        if (delay === void 0) { delay = 0; }\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        var actions = scheduler.actions;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            immediateProvider.clearImmediate(id);\n            if (scheduler._scheduled === id) {\n                scheduler._scheduled = undefined;\n            }\n        }\n        return undefined;\n    };\n    return AsapAction;\n}(AsyncAction));\nexport { AsapAction };\n//# sourceMappingURL=AsapAction.js.map","import { __extends } from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AsapScheduler = (function (_super) {\n    __extends(AsapScheduler, _super);\n    function AsapScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AsapScheduler.prototype.flush = function (action) {\n        this._active = true;\n        var flushId = this._scheduled;\n        this._scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsapScheduler;\n}(AsyncScheduler));\nexport { AsapScheduler };\n//# sourceMappingURL=AsapScheduler.js.map","import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\nexport var asapScheduler = new AsapScheduler(AsapAction);\nexport var asap = asapScheduler;\n//# sourceMappingURL=asap.js.map","import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nvar QueueAction = (function (_super) {\n    __extends(QueueAction, _super);\n    function QueueAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    QueueAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay > 0) {\n            return _super.prototype.schedule.call(this, state, delay);\n        }\n        this.delay = delay;\n        this.state = state;\n        this.scheduler.flush(this);\n        return this;\n    };\n    QueueAction.prototype.execute = function (state, delay) {\n        return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay);\n    };\n    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.flush(this);\n        return 0;\n    };\n    return QueueAction;\n}(AsyncAction));\nexport { QueueAction };\n//# sourceMappingURL=QueueAction.js.map","import { __extends } from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar QueueScheduler = (function (_super) {\n    __extends(QueueScheduler, _super);\n    function QueueScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    return QueueScheduler;\n}(AsyncScheduler));\nexport { QueueScheduler };\n//# sourceMappingURL=QueueScheduler.js.map","import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\nexport var queueScheduler = new QueueScheduler(QueueAction);\nexport var queue = queueScheduler;\n//# sourceMappingURL=queue.js.map","import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { animationFrameProvider } from './animationFrameProvider';\nvar AnimationFrameAction = (function (_super) {\n    __extends(AnimationFrameAction, _super);\n    function AnimationFrameAction(scheduler, work) {\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        return _this;\n    }\n    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (delay !== null && delay > 0) {\n            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);\n        }\n        scheduler.actions.push(this);\n        return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(function () { return scheduler.flush(undefined); }));\n    };\n    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        var _a;\n        if (delay === void 0) { delay = 0; }\n        if (delay != null ? delay > 0 : this.delay > 0) {\n            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);\n        }\n        var actions = scheduler.actions;\n        if (id != null && ((_a = actions[actions.length - 1]) === null || _a === void 0 ? void 0 : _a.id) !== id) {\n            animationFrameProvider.cancelAnimationFrame(id);\n            scheduler._scheduled = undefined;\n        }\n        return undefined;\n    };\n    return AnimationFrameAction;\n}(AsyncAction));\nexport { AnimationFrameAction };\n//# sourceMappingURL=AnimationFrameAction.js.map","import { __extends } from \"tslib\";\nimport { AsyncScheduler } from './AsyncScheduler';\nvar AnimationFrameScheduler = (function (_super) {\n    __extends(AnimationFrameScheduler, _super);\n    function AnimationFrameScheduler() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    AnimationFrameScheduler.prototype.flush = function (action) {\n        this._active = true;\n        var flushId = this._scheduled;\n        this._scheduled = undefined;\n        var actions = this.actions;\n        var error;\n        action = action || actions.shift();\n        do {\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        } while ((action = actions[0]) && action.id === flushId && actions.shift());\n        this._active = false;\n        if (error) {\n            while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AnimationFrameScheduler;\n}(AsyncScheduler));\nexport { AnimationFrameScheduler };\n//# sourceMappingURL=AnimationFrameScheduler.js.map","import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nexport var animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\nexport var animationFrame = animationFrameScheduler;\n//# sourceMappingURL=animationFrame.js.map","import { __extends } from \"tslib\";\nimport { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nvar VirtualTimeScheduler = (function (_super) {\n    __extends(VirtualTimeScheduler, _super);\n    function VirtualTimeScheduler(schedulerActionCtor, maxFrames) {\n        if (schedulerActionCtor === void 0) { schedulerActionCtor = VirtualAction; }\n        if (maxFrames === void 0) { maxFrames = Infinity; }\n        var _this = _super.call(this, schedulerActionCtor, function () { return _this.frame; }) || this;\n        _this.maxFrames = maxFrames;\n        _this.frame = 0;\n        _this.index = -1;\n        return _this;\n    }\n    VirtualTimeScheduler.prototype.flush = function () {\n        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;\n        var error;\n        var action;\n        while ((action = actions[0]) && action.delay <= maxFrames) {\n            actions.shift();\n            this.frame = action.delay;\n            if ((error = action.execute(action.state, action.delay))) {\n                break;\n            }\n        }\n        if (error) {\n            while ((action = actions.shift())) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    VirtualTimeScheduler.frameTimeFactor = 10;\n    return VirtualTimeScheduler;\n}(AsyncScheduler));\nexport { VirtualTimeScheduler };\nvar VirtualAction = (function (_super) {\n    __extends(VirtualAction, _super);\n    function VirtualAction(scheduler, work, index) {\n        if (index === void 0) { index = (scheduler.index += 1); }\n        var _this = _super.call(this, scheduler, work) || this;\n        _this.scheduler = scheduler;\n        _this.work = work;\n        _this.index = index;\n        _this.active = true;\n        _this.index = scheduler.index = index;\n        return _this;\n    }\n    VirtualAction.prototype.schedule = function (state, delay) {\n        if (delay === void 0) { delay = 0; }\n        if (Number.isFinite(delay)) {\n            if (!this.id) {\n                return _super.prototype.schedule.call(this, state, delay);\n            }\n            this.active = false;\n            var action = new VirtualAction(this.scheduler, this.work);\n            this.add(action);\n            return action.schedule(state, delay);\n        }\n        else {\n            return Subscription.EMPTY;\n        }\n    };\n    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        this.delay = scheduler.frame + delay;\n        var actions = scheduler.actions;\n        actions.push(this);\n        actions.sort(VirtualAction.sortActions);\n        return 1;\n    };\n    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {\n        if (delay === void 0) { delay = 0; }\n        return undefined;\n    };\n    VirtualAction.prototype._execute = function (state, delay) {\n        if (this.active === true) {\n            return _super.prototype._execute.call(this, state, delay);\n        }\n    };\n    VirtualAction.sortActions = function (a, b) {\n        if (a.delay === b.delay) {\n            if (a.index === b.index) {\n                return 0;\n            }\n            else if (a.index > b.index) {\n                return 1;\n            }\n            else {\n                return -1;\n            }\n        }\n        else if (a.delay > b.delay) {\n            return 1;\n        }\n        else {\n            return -1;\n        }\n    };\n    return VirtualAction;\n}(AsyncAction));\nexport { VirtualAction };\n//# sourceMappingURL=VirtualTimeScheduler.js.map","import { Observable } from '../Observable';\nimport { isFunction } from './isFunction';\nexport function isObservable(obj) {\n    return !!obj && (obj instanceof Observable || (isFunction(obj.lift) && isFunction(obj.subscribe)));\n}\n//# sourceMappingURL=isObservable.js.map","import { EmptyError } from './util/EmptyError';\nexport function lastValueFrom(source, config) {\n    var hasConfig = typeof config === 'object';\n    return new Promise(function (resolve, reject) {\n        var _hasValue = false;\n        var _value;\n        source.subscribe({\n            next: function (value) {\n                _value = value;\n                _hasValue = true;\n            },\n            error: reject,\n            complete: function () {\n                if (_hasValue) {\n                    resolve(_value);\n                }\n                else if (hasConfig) {\n                    resolve(config.defaultValue);\n                }\n                else {\n                    reject(new EmptyError());\n                }\n            },\n        });\n    });\n}\n//# sourceMappingURL=lastValueFrom.js.map","import { __read, __spreadArray } from \"tslib\";\nimport { isScheduler } from '../util/isScheduler';\nimport { Observable } from '../Observable';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { observeOn } from '../operators/observeOn';\nimport { AsyncSubject } from '../AsyncSubject';\nexport function bindCallbackInternals(isNodeStyle, callbackFunc, resultSelector, scheduler) {\n    if (resultSelector) {\n        if (isScheduler(resultSelector)) {\n            scheduler = resultSelector;\n        }\n        else {\n            return function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                return bindCallbackInternals(isNodeStyle, callbackFunc, scheduler)\n                    .apply(this, args)\n                    .pipe(mapOneOrManyArgs(resultSelector));\n            };\n        }\n    }\n    if (scheduler) {\n        return function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return bindCallbackInternals(isNodeStyle, callbackFunc)\n                .apply(this, args)\n                .pipe(subscribeOn(scheduler), observeOn(scheduler));\n        };\n    }\n    return function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var subject = new AsyncSubject();\n        var uninitialized = true;\n        return new Observable(function (subscriber) {\n            var subs = subject.subscribe(subscriber);\n            if (uninitialized) {\n                uninitialized = false;\n                var isAsync_1 = false;\n                var isComplete_1 = false;\n                callbackFunc.apply(_this, __spreadArray(__spreadArray([], __read(args)), [\n                    function () {\n                        var results = [];\n                        for (var _i = 0; _i < arguments.length; _i++) {\n                            results[_i] = arguments[_i];\n                        }\n                        if (isNodeStyle) {\n                            var err = results.shift();\n                            if (err != null) {\n                                subject.error(err);\n                                return;\n                            }\n                        }\n                        subject.next(1 < results.length ? results : results[0]);\n                        isComplete_1 = true;\n                        if (isAsync_1) {\n                            subject.complete();\n                        }\n                    },\n                ]));\n                if (isComplete_1) {\n                    subject.complete();\n                }\n                isAsync_1 = true;\n            }\n            return subs;\n        });\n    };\n}\n//# sourceMappingURL=bindCallbackInternals.js.map","import { bindCallbackInternals } from './bindCallbackInternals';\nexport function bindCallback(callbackFunc, resultSelector, scheduler) {\n    return bindCallbackInternals(false, callbackFunc, resultSelector, scheduler);\n}\n//# sourceMappingURL=bindCallback.js.map","import { bindCallbackInternals } from './bindCallbackInternals';\nexport function bindNodeCallback(callbackFunc, resultSelector, scheduler) {\n    return bindCallbackInternals(true, callbackFunc, resultSelector, scheduler);\n}\n//# sourceMappingURL=bindNodeCallback.js.map","import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { defer } from './defer';\nvar DEFAULT_CONFIG = {\n    connector: function () { return new Subject(); },\n    resetOnDisconnect: true,\n};\nexport function connectable(source, config) {\n    if (config === void 0) { config = DEFAULT_CONFIG; }\n    var connection = null;\n    var connector = config.connector, _a = config.resetOnDisconnect, resetOnDisconnect = _a === void 0 ? true : _a;\n    var subject = connector();\n    var result = new Observable(function (subscriber) {\n        return subject.subscribe(subscriber);\n    });\n    result.connect = function () {\n        if (!connection || connection.closed) {\n            connection = defer(function () { return source; }).subscribe(subject);\n            if (resetOnDisconnect) {\n                connection.add(function () { return (subject = connector()); });\n            }\n        }\n        return connection;\n    };\n    return result;\n}\n//# sourceMappingURL=connectable.js.map","import { Observable } from '../Observable';\nimport { argsArgArrayOrObject } from '../util/argsArgArrayOrObject';\nimport { innerFrom } from './innerFrom';\nimport { popResultSelector } from '../util/args';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\nimport { createObject } from '../util/createObject';\nexport function forkJoin() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var resultSelector = popResultSelector(args);\n    var _a = argsArgArrayOrObject(args), sources = _a.args, keys = _a.keys;\n    var result = new Observable(function (subscriber) {\n        var length = sources.length;\n        if (!length) {\n            subscriber.complete();\n            return;\n        }\n        var values = new Array(length);\n        var remainingCompletions = length;\n        var remainingEmissions = length;\n        var _loop_1 = function (sourceIndex) {\n            var hasValue = false;\n            innerFrom(sources[sourceIndex]).subscribe(createOperatorSubscriber(subscriber, function (value) {\n                if (!hasValue) {\n                    hasValue = true;\n                    remainingEmissions--;\n                }\n                values[sourceIndex] = value;\n            }, function () { return remainingCompletions--; }, undefined, function () {\n                if (!remainingCompletions || !hasValue) {\n                    if (!remainingEmissions) {\n                        subscriber.next(keys ? createObject(keys, values) : values);\n                    }\n                    subscriber.complete();\n                }\n            }));\n        };\n        for (var sourceIndex = 0; sourceIndex < length; sourceIndex++) {\n            _loop_1(sourceIndex);\n        }\n    });\n    return resultSelector ? result.pipe(mapOneOrManyArgs(resultSelector)) : result;\n}\n//# sourceMappingURL=forkJoin.js.map","import { __generator } from \"tslib\";\nimport { identity } from '../util/identity';\nimport { isScheduler } from '../util/isScheduler';\nimport { defer } from './defer';\nimport { scheduleIterable } from '../scheduled/scheduleIterable';\nexport function generate(initialStateOrOptions, condition, iterate, resultSelectorOrScheduler, scheduler) {\n    var _a, _b;\n    var resultSelector;\n    var initialState;\n    if (arguments.length === 1) {\n        (_a = initialStateOrOptions, initialState = _a.initialState, condition = _a.condition, iterate = _a.iterate, _b = _a.resultSelector, resultSelector = _b === void 0 ? identity : _b, scheduler = _a.scheduler);\n    }\n    else {\n        initialState = initialStateOrOptions;\n        if (!resultSelectorOrScheduler || isScheduler(resultSelectorOrScheduler)) {\n            resultSelector = identity;\n            scheduler = resultSelectorOrScheduler;\n        }\n        else {\n            resultSelector = resultSelectorOrScheduler;\n        }\n    }\n    function gen() {\n        var state;\n        return __generator(this, function (_a) {\n            switch (_a.label) {\n                case 0:\n                    state = initialState;\n                    _a.label = 1;\n                case 1:\n                    if (!(!condition || condition(state))) return [3, 4];\n                    return [4, resultSelector(state)];\n                case 2:\n                    _a.sent();\n                    _a.label = 3;\n                case 3:\n                    state = iterate(state);\n                    return [3, 1];\n                case 4: return [2];\n            }\n        });\n    }\n    return defer((scheduler\n        ?\n            function () { return scheduleIterable(gen(), scheduler); }\n        :\n            gen));\n}\n//# sourceMappingURL=generate.js.map","import { defer } from './defer';\nexport function iif(condition, trueResult, falseResult) {\n    return defer(function () { return (condition() ? trueResult : falseResult); });\n}\n//# sourceMappingURL=iif.js.map","import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\nexport var NEVER = new Observable(noop);\nexport function never() {\n    return NEVER;\n}\n//# sourceMappingURL=never.js.map","import { from } from './from';\nexport function pairs(obj, scheduler) {\n    return from(Object.entries(obj), scheduler);\n}\n//# sourceMappingURL=pairs.js.map","import { not } from '../util/not';\nimport { filter } from '../operators/filter';\nimport { innerFrom } from './innerFrom';\nexport function partition(source, predicate, thisArg) {\n    return [filter(predicate, thisArg)(innerFrom(source)), filter(not(predicate, thisArg))(innerFrom(source))];\n}\n//# sourceMappingURL=partition.js.map","import { Observable } from '../Observable';\nimport { EMPTY } from './empty';\nexport function range(start, count, scheduler) {\n    if (count == null) {\n        count = start;\n        start = 0;\n    }\n    if (count <= 0) {\n        return EMPTY;\n    }\n    var end = count + start;\n    return new Observable(scheduler\n        ?\n            function (subscriber) {\n                var n = start;\n                return scheduler.schedule(function () {\n                    if (n < end) {\n                        subscriber.next(n++);\n                        this.schedule();\n                    }\n                    else {\n                        subscriber.complete();\n                    }\n                });\n            }\n        :\n            function (subscriber) {\n                var n = start;\n                while (n < end && !subscriber.closed) {\n                    subscriber.next(n++);\n                }\n                subscriber.complete();\n            });\n}\n//# sourceMappingURL=range.js.map","import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nexport function using(resourceFactory, observableFactory) {\n    return new Observable(function (subscriber) {\n        var resource = resourceFactory();\n        var result = observableFactory(resource);\n        var source = result ? innerFrom(result) : EMPTY;\n        source.subscribe(subscriber);\n        return function () {\n            if (resource) {\n                resource.unsubscribe();\n            }\n        };\n    });\n}\n//# sourceMappingURL=using.js.map","import { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\nexport function merge() {\n    var args = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n    }\n    var scheduler = popScheduler(args);\n    var concurrent = popNumber(args, Infinity);\n    var sources = args;\n    return !sources.length\n        ?\n            EMPTY\n        : sources.length === 1\n            ?\n                innerFrom(sources[0])\n            :\n                mergeAll(concurrent)(from(sources, scheduler));\n}\n//# sourceMappingURL=merge.js.map"],"sourceRoot":""}