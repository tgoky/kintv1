{"version":3,"sources":["features/data/apis/allowance/allowance.ts"],"names":["BeefyV2AppMulticallUserAbi","_BeefyV2AppMulticallUserAbi","AllowanceAPI","constructor","web3","chain","fetchAllAllowances","state","standardVaults","govVaults","boosts","walletAddress","mc","this","eth","Contract","fetchBalancesAddress","allowanceCallsByToken","tokensByAddress","addTokenAddressesToCalls","tokenAddress","spenderAddress","token","selectTokenByAddress","id","keyTokenAddress","address","toLowerCase","isTokenErc20","Error","concat","undefined","spenders","Set","add","standardVault","earnedTokenAddress","earnContractAddress","depositTokenAddress","govVault","boost","selectVaultById","vaultId","CHUNK_SIZE","featureFlag_getAllowanceApiChunkSize","allowanceCalls","Object","entries","callBatches","chunk","allowancePromises","map","callBatch","methods","getAllowancesFlat","_ref","_","_ref2","spendersCalls","Array","from","call","results","Promise","all","res","resultsIdx","batchResults","resIdx","c","allowance","push","BigNumber","shiftedBy","decimals","fetchTokensAllowance","tokens","_ref3","_ref4"],"mappings":"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","file":"static/js/33.51bb3689.chunk.js","sourcesContent":["import _BeefyV2AppMulticallUserAbi from '../../../../config/abi/BeefyV2AppUserMulticall.json';\nimport { AbiItem } from 'web3-utils';\nimport Web3 from 'web3';\nimport { VaultGov, VaultStandard } from '../../entities/vault';\nimport { ChainEntity } from '../../entities/chain';\nimport BigNumber from 'bignumber.js';\nimport { AllValuesAsString } from '../../utils/types-utils';\nimport { BoostEntity } from '../../entities/boost';\nimport { chunk } from 'lodash';\nimport { isTokenErc20, TokenEntity, TokenErc20 } from '../../entities/token';\nimport { FetchAllAllowanceResult, IAllowanceApi } from './allowance-types';\nimport { selectTokenByAddress } from '../../selectors/tokens';\nimport { featureFlag_getAllowanceApiChunkSize } from '../../utils/feature-flags';\nimport { BeefyState } from '../../../../redux-types';\nimport { selectVaultById } from '../../selectors/vaults';\n\n// fix ts types\nconst BeefyV2AppMulticallUserAbi = _BeefyV2AppMulticallUserAbi as AbiItem | AbiItem[];\n\nexport class AllowanceAPI<T extends ChainEntity & { fetchBalancesAddress: string }>\n  implements IAllowanceApi\n{\n  constructor(protected web3: Web3, protected chain: T) {}\n\n  public async fetchAllAllowances(\n    state: BeefyState,\n    standardVaults: VaultStandard[],\n    govVaults: VaultGov[],\n    boosts: BoostEntity[],\n    walletAddress: string\n  ): Promise<FetchAllAllowanceResult> {\n    const mc = new this.web3.eth.Contract(\n      BeefyV2AppMulticallUserAbi,\n      this.chain.fetchBalancesAddress\n    );\n\n    // first, build a list of tokens and spenders we want info on\n    const allowanceCallsByToken: {\n      [tokenAddress: string]: { tokenAddress: TokenEntity['address']; spenders: Set<string> };\n    } = {};\n    const tokensByAddress: { [tokenAddress: TokenEntity['address']]: TokenEntity } = {};\n    const addTokenAddressesToCalls = (tokenAddress: string, spenderAddress: string) => {\n      const token = selectTokenByAddress(state, this.chain.id, tokenAddress);\n      const keyTokenAddress = token.address.toLowerCase();\n      if (!isTokenErc20(token)) {\n        throw new Error(`Can't query allowance of non erc20 token, skipping ${token.id}`);\n      }\n      if (allowanceCallsByToken[keyTokenAddress] === undefined) {\n        allowanceCallsByToken[keyTokenAddress] = {\n          tokenAddress: token.address,\n          spenders: new Set(),\n        };\n      }\n      allowanceCallsByToken[keyTokenAddress].spenders.add(spenderAddress);\n      // keep a map to get decimals at the end\n      if (tokensByAddress[keyTokenAddress] === undefined) {\n        tokensByAddress[keyTokenAddress] = token;\n      }\n    };\n\n    for (const standardVault of standardVaults) {\n      addTokenAddressesToCalls(standardVault.earnedTokenAddress, standardVault.earnContractAddress);\n      addTokenAddressesToCalls(\n        standardVault.depositTokenAddress,\n        standardVault.earnContractAddress\n      );\n    }\n    for (const govVault of govVaults) {\n      addTokenAddressesToCalls(govVault.depositTokenAddress, govVault.earnContractAddress);\n    }\n    for (const boost of boosts) {\n      const vault = selectVaultById(state, boost.vaultId);\n      addTokenAddressesToCalls(vault.earnedTokenAddress, boost.earnContractAddress);\n    }\n\n    // if we send too much in a single call, we get \"execution reversed\"\n    const CHUNK_SIZE = featureFlag_getAllowanceApiChunkSize();\n\n    const allowanceCalls = Object.entries(allowanceCallsByToken);\n    const callBatches = chunk(allowanceCalls, CHUNK_SIZE);\n\n    const allowancePromises = callBatches.map(callBatch =>\n      mc.methods\n        .getAllowancesFlat(\n          callBatch.map(([tokenAddress, _]) => tokenAddress),\n          callBatch.map(([_, spendersCalls]) => Array.from(spendersCalls.spenders)),\n          walletAddress\n        )\n        .call()\n    );\n\n    const results = (await Promise.all([...allowancePromises])) as AllValuesAsString<string[][]>;\n\n    // now reasign results\n    const res: FetchAllAllowanceResult = [];\n\n    let resultsIdx = 0;\n\n    for (const callBatch of callBatches) {\n      const batchResults = results[resultsIdx];\n      let resIdx = 0;\n      for (const spendersCalls of callBatch.map(c => c[1])) {\n        for (const spenderAddress of Array.from(spendersCalls.spenders)) {\n          const allowance = batchResults[resIdx];\n          if (allowance !== '0') {\n            res.push({\n              tokenAddress: spendersCalls.tokenAddress,\n              spenderAddress,\n              allowance: new BigNumber(allowance).shiftedBy(\n                -tokensByAddress[spendersCalls.tokenAddress.toLowerCase()].decimals\n              ),\n            });\n          }\n          resIdx++;\n        }\n      }\n      resultsIdx++;\n    }\n\n    return res;\n  }\n\n  async fetchTokensAllowance(\n    state: BeefyState,\n    tokens: TokenErc20[],\n    walletAddress: string,\n    spenderAddress: string\n  ) {\n    const mc = new this.web3.eth.Contract(\n      BeefyV2AppMulticallUserAbi,\n      this.chain.fetchBalancesAddress\n    );\n\n    // first, build a list of tokens and spenders we want info on\n    const allowanceCallsByToken: {\n      [tokenAddress: string]: { tokenAddress: TokenEntity['address']; spenders: Set<string> };\n    } = {};\n    const tokensByAddress: { [tokenAddress: TokenEntity['address']]: TokenEntity } = {};\n    const addTokenAddressesToCalls = (tokenAddress: string, spenderAddress: string) => {\n      const token = selectTokenByAddress(state, this.chain.id, tokenAddress);\n      const keyTokenAddress = token.address.toLowerCase();\n      if (!isTokenErc20(token)) {\n        throw new Error(`Can't query allowance of non erc20 token, skipping ${token.id}`);\n      }\n      if (allowanceCallsByToken[keyTokenAddress] === undefined) {\n        allowanceCallsByToken[keyTokenAddress] = {\n          tokenAddress: token.address,\n          spenders: new Set(),\n        };\n      }\n      allowanceCallsByToken[keyTokenAddress].spenders.add(spenderAddress);\n      // keep a map to get decimals at the end\n      if (tokensByAddress[keyTokenAddress] === undefined) {\n        tokensByAddress[keyTokenAddress] = token;\n      }\n    };\n\n    for (const token of tokens) {\n      addTokenAddressesToCalls(token.address, spenderAddress);\n    }\n\n    // if we send too much in a single call, we get \"execution reversed\"\n    const CHUNK_SIZE = featureFlag_getAllowanceApiChunkSize();\n\n    const allowanceCalls = Object.entries(allowanceCallsByToken);\n    const callBatches = chunk(allowanceCalls, CHUNK_SIZE);\n\n    const allowancePromises = callBatches.map(callBatch =>\n      mc.methods\n        .getAllowancesFlat(\n          callBatch.map(([tokenAddress, _]) => tokenAddress),\n          callBatch.map(([_, spendersCalls]) => Array.from(spendersCalls.spenders)),\n          walletAddress\n        )\n        .call()\n    );\n\n    const results = (await Promise.all([...allowancePromises])) as AllValuesAsString<string[][]>;\n\n    const res: FetchAllAllowanceResult = [];\n\n    let resultsIdx = 0;\n\n    for (const callBatch of callBatches) {\n      const batchResults = results[resultsIdx];\n      let resIdx = 0;\n      for (const spendersCalls of callBatch.map(c => c[1])) {\n        for (const spenderAddress of Array.from(spendersCalls.spenders)) {\n          const allowance = batchResults[resIdx];\n          if (allowance !== '0') {\n            res.push({\n              tokenAddress: spendersCalls.tokenAddress,\n              spenderAddress,\n              allowance: new BigNumber(allowance).shiftedBy(\n                -tokensByAddress[spendersCalls.tokenAddress.toLowerCase()].decimals\n              ),\n            });\n          }\n          resIdx++;\n        }\n      }\n      resultsIdx++;\n    }\n\n    return res;\n  }\n}\n"],"sourceRoot":""}